name: CI

on:
  push:
    branches: ["**"]
  pull_request:
    branches: ["main", "develop"]
  workflow_dispatch:
    inputs:
      branch:
        description: "Source branch to open a PR from (must start with feat/ or feature/)"
        required: true
        type: string

permissions:
  contents: read

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true

env:
  CI: true
  NEXT_TELEMETRY_DISABLED: 1

jobs:
  quality:
    name: Lint & Typecheck
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Cache Bun store
        uses: actions/cache@v4
        with:
          path: |
            ~/.bun/install/cache
          key: ${{ runner.os }}-bun-${{ hashFiles('**/bun.lockb', '**/bun.lock') }}
          restore-keys: |
            ${{ runner.os }}-bun-

      - name: Install deps
        run: bun install --frozen-lockfile

      - name: Lint
        run: bun run lint

      - name: Typecheck
        run: bun run typecheck

  build:
    name: Build
    runs-on: ubuntu-latest
    needs: quality
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Cache Bun store
        uses: actions/cache@v4
        with:
          path: |
            ~/.bun/install/cache
          key: ${{ runner.os }}-bun-${{ hashFiles('**/bun.lockb', '**/bun.lock') }}
          restore-keys: |
            ${{ runner.os }}-bun-

      - name: Restore Next build cache
        uses: actions/cache@v4
        with:
          path: .next/cache
          key: ${{ runner.os }}-next-${{ hashFiles('**/bun.lock', '**/bun.lockb') }}-${{ hashFiles('next.config.*', 'tsconfig.json', 'package.json', 'app/**/*.tsx', 'lib/**/*.ts', 'lib/**/*.tsx') }}
          restore-keys: |
            ${{ runner.os }}-next-${{ hashFiles('**/bun.lock', '**/bun.lockb') }}-
            ${{ runner.os }}-next-

      - name: Install deps
        run: bun install --frozen-lockfile

      - name: Generate Prisma Client
        run: bun run prisma:generate

      - name: Build
        env:
          NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL != '' && secrets.NEXT_PUBLIC_SUPABASE_URL || 'https://placeholder.supabase.co' }}
          NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY != '' && secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY || 'placeholder-anon-key' }}
          RESEND_API_KEY: ${{ secrets.RESEND_API_KEY != '' && secrets.RESEND_API_KEY || 'placeholder-resend-key' }}
        run: bun run build

      - name: Upload build artifact
        if: success()
        uses: actions/upload-artifact@v4
        with:
          name: next-build
          path: |
            .next
            package.json
            bun.lock
            bun.lockb
          retention-days: 7

  deploy:
    name: Deploy Production
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    needs: build
    runs-on: ubuntu-latest
    permissions:
      contents: read
      deployments: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download build artifact (optional)
        uses: actions/download-artifact@v4
        with:
            name: next-build
            path: .

      - name: Deploy to Vercel (Production)
        uses: amondnet/vercel-action@v25
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
          vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
          working-directory: .
          vercel-args: "--prod"
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}

  preview:
    name: Deploy Preview
    if: github.event_name == 'pull_request'
    needs: build
    runs-on: ubuntu-latest
    permissions:
      contents: read
      deployments: write
      pull-requests: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: next-build
          path: .

      - name: Deploy to Vercel (Preview)
        uses: amondnet/vercel-action@v25
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
          vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
          working-directory: .
          # Sem --prod para gerar preview
          github-comment: true
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}

  auto-pr:
    name: Create Pull Request
    # Run on push to feat*/feature*/develop OR manual dispatch with a matching branch input
    if: >-
      ${{
        (github.event_name == 'push' &&
          (startsWith(github.ref, 'refs/heads/feat/') ||
           startsWith(github.ref, 'refs/heads/feature/') ||
           github.ref == 'refs/heads/develop'))
        ||
        (github.event_name == 'workflow_dispatch' &&
          (startsWith(github.event.inputs.branch, 'feat/') ||
           startsWith(github.event.inputs.branch, 'feature/') ||
           github.event.inputs.branch == 'develop'))
      }}
    needs: build
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Open PR if not already open
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PR_AUTOMATION_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const { execSync } = require('child_process');
            
            const fromDispatch = context.eventName === 'workflow_dispatch'
            const inputBranch = fromDispatch ? (context.payload?.inputs?.branch || '') : ''
            const branchRef = fromDispatch ? `refs/heads/${inputBranch}` : context.ref // e.g., refs/heads/feat/my-branch
            const branch = fromDispatch ? inputBranch : branchRef.replace('refs/heads/', '')
            if (fromDispatch && !branch) {
              core.setFailed('No branch provided in workflow_dispatch inputs.')
              return
            }
            // If branch is develop, target main; otherwise target develop
            const base = branch === 'develop' ? 'main' : 'develop';

            if (branch === base) {
              core.info(`Branch '${branch}' is the base branch. Skipping PR creation.`)
              return
            }

            // Try to find an existing PR. Some tokens without repo access may 404; handle gracefully.
            let prs = []
            try {
              const res = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                head: `${context.repo.owner}:${branch}`,
                base,
                state: 'open',
                per_page: 1,
              })
              prs = res.data
            } catch (err) {
              if (err.status === 404) {
                core.warning('Could not list PRs (404). Proceeding to attempt creation. Ensure the token has access to this repository.');
              } else {
                throw err
              }
            }

            if (prs.length > 0) {
              core.info(`PR already exists: #${prs[0].number} ${prs[0].html_url}`)
              return
            }

            // Generate PR description from commits
            let commits = [];
            let commitList = '';
            try {
              // Get commits between base and current branch
              const comparison = await github.rest.repos.compareCommits({
                owner: context.repo.owner,
                repo: context.repo.repo,
                base,
                head: branch,
              });
              
              commits = comparison.data.commits || [];
              
              if (commits.length > 0) {
                commitList = commits.map(commit => {
                  const msg = commit.commit.message.split('\n')[0]; // First line only
                  const shortSha = commit.sha.substring(0, 7);
                  return `- ${msg} (\`${shortSha}\`)`;
                }).join('\n');
              }
            } catch (err) {
              core.warning(`Could not fetch commits: ${err.message}`);
              commitList = '*(Could not fetch commit list)*';
            }

            const clean = branch.replace(/^feat\//, '').replace(/^feature\//, '')
            const isRelease = branch === 'develop'
            const title = isRelease ? 'chore: release develop to main' : `feat: ${clean}`
            const body = isRelease ? [
              '## ğŸš€ Release to Production',
              '',
              `**Branch:** \`${branch}\``,
              `**Target:** \`${base}\``,
              `**Commits:** ${commits.length}`,
              '',
              '## ğŸ“ Changes',
              '',
              commitList || '*(No commits found)*',
              '',
              '## âœ… Review Checklist',
              '',
              '- [ ] All tests are passing',
              '- [ ] Build is successful',
              '- [ ] No breaking changes',
              '- [ ] Documentation updated',
              '- [ ] Ready for production deployment',
              '',
              '---',
              '*This pull request was opened automatically by CI.*'
            ].join('\n') : [
              '## ğŸš€ Feature',
              '',
              `**Branch:** \`${branch}\``,
              `**Target:** \`${base}\``,
              `**Commits:** ${commits.length}`,
              '',
              '## ğŸ“ Changes',
              '',
              commitList || '*(No commits found)*',
              '',
              '## âœ… Checklist',
              '',
              '- [ ] Code follows project conventions',
              '- [ ] All tests are passing',
              '- [ ] No console errors',
              '- [ ] Documentation updated if needed',
              '',
              '---',
              '*This pull request was opened automatically by CI.*'
            ].join('\n')

            try {
              const res = await github.rest.pulls.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                head: branch,
                base,
                title,
                body,
                maintainer_can_modify: true,
              })
              core.info(`Created PR #${res.data.number}: ${res.data.html_url}`)
            } catch (err) {
              if (err.status === 403) {
                core.setFailed('Permission denied to create PR. If using GITHUB_TOKEN, enable "Allow GitHub Actions to create and approve pull requests" in Repository Settings > Actions > General. Otherwise, provide a PAT in PR_AUTOMATION_TOKEN with repo access (Contents + Pull requests: Read & Write).')
              } else if (err.status === 404) {
                core.setFailed('Not Found creating PR. The token likely does not have access to this private repository. Use a PAT (classic with repo scope, or fine-grained with access to this repo and Pull requests: Read & Write).')
              } else {
                throw err
              }
            }

  auto-pr-develop-to-main:
    name: Create PR from Develop to Main
    # Run when there's a push to develop branch (typically after merging feature branches)
    if: github.event_name == 'push' && github.ref == 'refs/heads/develop'
    needs: build
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch full history to check for recent merges

      - name: Check if recent merge from feature branch and create PR
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PR_AUTOMATION_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            // Check if this push was a merge from a feature/feat branch
            const { execSync } = require('child_process');
            
            try {
              // Get the commit message of the latest commit
              const commitMessage = execSync('git log -1 --pretty=%s', { encoding: 'utf-8' }).trim();
              console.log(`Latest commit message: ${commitMessage}`);
              
              // Check if it's a merge commit from a feature/feat branch
              const isMergeFromFeature = commitMessage.includes('Merge') && 
                                        (commitMessage.includes('feat/') || commitMessage.includes('feature/'));
              
              if (!isMergeFromFeature) {
                core.info('This push is not a merge from a feature branch. Skipping PR creation.');
                return;
              }
              
              console.log('Detected merge from feature branch to develop. Creating PR to main...');
              
            } catch (error) {
              core.warning(`Could not check git history: ${error.message}`);
              // Continue anyway - we still want to create the PR if develop has new commits
            }

            const head = 'develop';
            const base = 'main';

            // Check if there's already an open PR from develop to main
            let existingPrs = [];
            try {
              const res = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                head: `${context.repo.owner}:${head}`,
                base,
                state: 'open',
                per_page: 1,
              });
              existingPrs = res.data;
            } catch (err) {
              if (err.status === 404) {
                core.warning('Could not list PRs (404). Proceeding to attempt creation.');
              } else {
                throw err;
              }
            }

            if (existingPrs.length > 0) {
              core.info(`PR from develop to main already exists: #${existingPrs[0].number} ${existingPrs[0].html_url}`);
              return;
            }

            // Check if develop is ahead of main
            try {
              const comparison = await github.rest.repos.compareCommits({
                owner: context.repo.owner,
                repo: context.repo.repo,
                base,
                head,
              });

              if (comparison.data.ahead_by === 0) {
                core.info('Develop branch is not ahead of main. No PR needed.');
                return;
              }

              console.log(`Develop is ${comparison.data.ahead_by} commits ahead of main.`);
              
              // Generate commit list for PR description
              const commits = comparison.data.commits || [];
              const commitList = commits.map(commit => {
                const msg = commit.commit.message.split('\n')[0]; // First line only
                const shortSha = commit.sha.substring(0, 7);
                const author = commit.commit.author.name;
                return `- ${msg} (\`${shortSha}\`) - @${author}`;
              }).join('\n');
              
              // Group commits by type if they follow conventional commits
              const groupedCommits = {
                feat: [],
                fix: [],
                chore: [],
                docs: [],
                refactor: [],
                test: [],
                other: []
              };
              
              commits.forEach(commit => {
                const msg = commit.commit.message.split('\n')[0];
                const shortSha = commit.sha.substring(0, 7);
                const author = commit.commit.author.name;
                const line = `- ${msg} (\`${shortSha}\`) - @${author}`;
                
                if (msg.startsWith('feat')) groupedCommits.feat.push(line);
                else if (msg.startsWith('fix')) groupedCommits.fix.push(line);
                else if (msg.startsWith('chore')) groupedCommits.chore.push(line);
                else if (msg.startsWith('docs')) groupedCommits.docs.push(line);
                else if (msg.startsWith('refactor')) groupedCommits.refactor.push(line);
                else if (msg.startsWith('test')) groupedCommits.test.push(line);
                else groupedCommits.other.push(line);
              });
              
              // Build organized commit section
              let organizedCommits = '';
              if (groupedCommits.feat.length > 0) {
                organizedCommits += '\n### âœ¨ Features\n' + groupedCommits.feat.join('\n') + '\n';
              }
              if (groupedCommits.fix.length > 0) {
                organizedCommits += '\n### ğŸ› Bug Fixes\n' + groupedCommits.fix.join('\n') + '\n';
              }
              if (groupedCommits.refactor.length > 0) {
                organizedCommits += '\n### â™»ï¸ Refactors\n' + groupedCommits.refactor.join('\n') + '\n';
              }
              if (groupedCommits.docs.length > 0) {
                organizedCommits += '\n### ğŸ“ Documentation\n' + groupedCommits.docs.join('\n') + '\n';
              }
              if (groupedCommits.test.length > 0) {
                organizedCommits += '\n### ğŸ§ª Tests\n' + groupedCommits.test.join('\n') + '\n';
              }
              if (groupedCommits.chore.length > 0) {
                organizedCommits += '\n### ğŸ”§ Chores\n' + groupedCommits.chore.join('\n') + '\n';
              }
              if (groupedCommits.other.length > 0) {
                organizedCommits += '\n### ğŸ“¦ Other Changes\n' + groupedCommits.other.join('\n') + '\n';
              }

              // Create the PR with enhanced description
              const title = 'chore: release develop to main';
              const body = [
                '## ğŸš€ Release to Production',
                '',
                `**Changes:** ${comparison.data.ahead_by} commits`,
                `**Branch:** \`${head}\` â†’ \`${base}\``,
                '',
                '## ğŸ“ Changes',
                organizedCommits,
                '',
                '## âœ… Review Checklist',
                '',
                '- [ ] All tests are passing âœ…',
                '- [ ] Build is successful âœ…',
                '- [ ] No breaking changes',
                '- [ ] Documentation updated',
                '- [ ] Ready for production deployment',
                '',
                '## ğŸ¯ Deploy Instructions',
                '',
                '1. Review all changes carefully',
                '2. Ensure CI checks pass',
                '3. Merge to trigger production deployment',
                '',
                '---',
                '*This PR was created automatically after feature branches were merged into develop.*'
              ].join('\n');

              try {
                const res = await github.rest.pulls.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  head,
                  base,
                  title,
                  body,
                  maintainer_can_modify: true,
                });
                core.info(`Created PR #${res.data.number}: ${res.data.html_url}`);
              } catch (err) {
                if (err.status === 403) {
                  core.setFailed('Permission denied to create PR. Ensure proper permissions are configured.');
                } else if (err.status === 404) {
                  core.setFailed('Not Found creating PR. Check repository access and token permissions.');
                } else if (err.status === 422) {
                  core.info('PR could not be created - likely no differences between branches or validation error.');
                } else {
                  throw err;
                }
              }
              
            } catch (err) {
              core.warning(`Could not compare branches: ${err.message}. Proceeding with PR creation.`);
            }
