name: CI

on:
  push:
    branches: ["**"]
  pull_request:
    branches: ["main", "develop"]
  workflow_dispatch:
    inputs:
      branch:
        description: "Source branch to open a PR from (must start with feat/ or feature/)"
        required: true
        type: string

permissions:
  contents: read

env:
  CI: true
  NEXT_TELEMETRY_DISABLED: 1

jobs:
  quality:
    name: Lint & Typecheck
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Cache Bun store
        uses: actions/cache@v4
        with:
          path: |
            ~/.bun/install/cache
            node_modules
          key: ${{ runner.os }}-bun-${{ hashFiles('**/bun.lockb', '**/bun.lock') }}
          restore-keys: |
            ${{ runner.os }}-bun-

      - name: Install deps
        run: bun install --frozen-lockfile

      - name: Lint
        run: bun run lint

      - name: Typecheck
        run: bun run typecheck

  build:
    name: Build
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: quality
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Cache Bun store
        uses: actions/cache@v4
        with:
          path: |
            ~/.bun/install/cache
            node_modules
          key: ${{ runner.os }}-bun-${{ hashFiles('**/bun.lockb', '**/bun.lock') }}
          restore-keys: |
            ${{ runner.os }}-bun-

      - name: Cache Next.js build
        uses: actions/cache@v4
        with:
          path: .next/cache
          key: ${{ runner.os }}-next-${{ hashFiles('**/bun.lock', '**/bun.lockb') }}-${{ hashFiles('**/*.ts', '**/*.tsx', '!node_modules/**') }}
          restore-keys: |
            ${{ runner.os }}-next-${{ hashFiles('**/bun.lock', '**/bun.lockb') }}-
            ${{ runner.os }}-next-

      - name: Install deps
        run: bun install --frozen-lockfile

      - name: Generate Prisma Client
        run: bun run prisma:generate

      - name: Validate required secrets
        run: |
          if [ -z "${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}" ]; then
            echo "::warning::NEXT_PUBLIC_SUPABASE_URL secret not configured - using placeholder"
          fi

      - name: Build
        env:
          NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL || 'https://placeholder.supabase.co' }}
          NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY || 'placeholder-anon-key' }}
          RESEND_API_KEY: ${{ secrets.RESEND_API_KEY || 'placeholder-resend-key' }}
        run: bun run build

      - name: Upload build artifact
        if: success()
        uses: actions/upload-artifact@v4
        with:
          name: next-build
          path: |
            .next
            public
            package.json
            bun.lock
            bun.lockb
            next.config.ts
            prisma/schema.prisma
          retention-days: 7

  deploy:
    name: Deploy Production
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    needs: build
    runs-on: ubuntu-latest
    timeout-minutes: 10
    permissions:
      contents: read
      deployments: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Deploy to Vercel (Production)
        id: vercel-deploy
        uses: amondnet/vercel-action@v25
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
          vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
          working-directory: .
          vercel-args: "--prod"
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}

      - name: Deployment Summary
        run: |
          echo "### üöÄ Production Deployment" >> $GITHUB_STEP_SUMMARY
          echo "- **URL:** ${{ steps.vercel-deploy.outputs.preview-url }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch:** main" >> $GITHUB_STEP_SUMMARY

  preview:
    name: Deploy Preview
    if: github.event_name == 'pull_request'
    needs: build
    runs-on: ubuntu-latest
    timeout-minutes: 10
    permissions:
      contents: read
      deployments: write
      pull-requests: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Deploy to Vercel (Preview)
        id: vercel-preview
        uses: amondnet/vercel-action@v25
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
          vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
          working-directory: .
          github-comment: true
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}

      - name: Preview Summary
        run: |
          echo "### üëÄ Preview Deployment" >> $GITHUB_STEP_SUMMARY
          echo "- **URL:** ${{ steps.vercel-preview.outputs.preview-url }}" >> $GITHUB_STEP_SUMMARY
          echo "- **PR:** #${{ github.event.pull_request.number }}" >> $GITHUB_STEP_SUMMARY

  auto-pr:
    name: Create Pull Request
    # Run on push to feat*/feature* branches only (develop‚Üímain is handled separately)
    if: >-
      ${{
        (github.event_name == 'push' &&
          (startsWith(github.ref, 'refs/heads/feat/') ||
           startsWith(github.ref, 'refs/heads/feature/')))
        ||
        (github.event_name == 'workflow_dispatch' &&
          (startsWith(github.event.inputs.branch, 'feat/') ||
           startsWith(github.event.inputs.branch, 'feature/')))
      }}
    needs: build
    runs-on: ubuntu-latest
    timeout-minutes: 5
    permissions:
      contents: read
      pull-requests: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Open PR if not already open
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PR_AUTOMATION_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const { execSync } = require('child_process');
            
            const fromDispatch = context.eventName === 'workflow_dispatch'
            const inputBranch = fromDispatch ? (context.payload?.inputs?.branch || '') : ''
            const branchRef = fromDispatch ? `refs/heads/${inputBranch}` : context.ref // e.g., refs/heads/feat/my-branch
            const branch = fromDispatch ? inputBranch : branchRef.replace('refs/heads/', '')
            if (fromDispatch && !branch) {
              core.setFailed('No branch provided in workflow_dispatch inputs.')
              return
            }
            // If branch is develop, target main; otherwise target develop
            const base = branch === 'develop' ? 'main' : 'develop';

            if (branch === base) {
              core.info(`Branch '${branch}' is the base branch. Skipping PR creation.`)
              return
            }

            // Try to find an existing PR. Some tokens without repo access may 404; handle gracefully.
            let prs = []
            try {
              const res = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                head: `${context.repo.owner}:${branch}`,
                base,
                state: 'open',
                per_page: 1,
              })
              prs = res.data
            } catch (err) {
              if (err.status === 404) {
                core.warning('Could not list PRs (404). Proceeding to attempt creation. Ensure the token has access to this repository.');
              } else {
                throw err
              }
            }

            if (prs.length > 0) {
              core.info(`PR already exists: #${prs[0].number} ${prs[0].html_url}`)
              return
            }

            // Generate PR description from commits
            let commits = [];
            let commitList = '';
            try {
              // Get commits between base and current branch
              const comparison = await github.rest.repos.compareCommits({
                owner: context.repo.owner,
                repo: context.repo.repo,
                base,
                head: branch,
              });
              
              commits = comparison.data.commits || [];
              
              if (commits.length > 0) {
                commitList = commits.map(commit => {
                  const msg = commit.commit.message.split('\n')[0]; // First line only
                  const shortSha = commit.sha.substring(0, 7);
                  return `- ${msg} (\`${shortSha}\`)`;
                }).join('\n');
              }
            } catch (err) {
              core.warning(`Could not fetch commits: ${err.message}`);
              commitList = '*(Could not fetch commit list)*';
            }

            const clean = branch.replace(/^feat\//, '').replace(/^feature\//, '')
            const isRelease = branch === 'develop'
            const title = isRelease ? 'chore: release develop to main' : `feat: ${clean}`
            const body = isRelease ? [
              '## üöÄ Release to Production',
              '',
              `**Branch:** \`${branch}\``,
              `**Target:** \`${base}\``,
              `**Commits:** ${commits.length}`,
              '',
              '## üìù Changes',
              '',
              commitList || '*(No commits found)*',
              '',
              '## ‚úÖ Review Checklist',
              '',
              '- [ ] All tests are passing',
              '- [ ] Build is successful',
              '- [ ] No breaking changes',
              '- [ ] Documentation updated',
              '- [ ] Ready for production deployment',
              '',
              '---',
              '*This pull request was opened automatically by CI.*'
            ].join('\n') : [
              '## üöÄ Feature',
              '',
              `**Branch:** \`${branch}\``,
              `**Target:** \`${base}\``,
              `**Commits:** ${commits.length}`,
              '',
              '## üìù Changes',
              '',
              commitList || '*(No commits found)*',
              '',
              '## ‚úÖ Checklist',
              '',
              '- [ ] Code follows project conventions',
              '- [ ] All tests are passing',
              '- [ ] No console errors',
              '- [ ] Documentation updated if needed',
              '',
              '---',
              '*This pull request was opened automatically by CI.*'
            ].join('\n')

            try {
              const res = await github.rest.pulls.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                head: branch,
                base,
                title,
                body,
                maintainer_can_modify: true,
              })
              core.info(`Created PR #${res.data.number}: ${res.data.html_url}`)
            } catch (err) {
              if (err.status === 403) {
                core.setFailed('Permission denied to create PR. If using GITHUB_TOKEN, enable "Allow GitHub Actions to create and approve pull requests" in Repository Settings > Actions > General. Otherwise, provide a PAT in PR_AUTOMATION_TOKEN with repo access (Contents + Pull requests: Read & Write).')
              } else if (err.status === 404) {
                core.setFailed('Not Found creating PR. The token likely does not have access to this private repository. Use a PAT (classic with repo scope, or fine-grained with access to this repo and Pull requests: Read & Write).')
              } else {
                throw err
              }
            }

  version-bump:
    name: Auto Version Bump
    # Run when there's a push to develop branch
    if: github.event_name == 'push' && github.ref == 'refs/heads/develop'
    needs: build
    runs-on: ubuntu-latest
    timeout-minutes: 5
    permissions:
      contents: write
    outputs:
      new_version: ${{ steps.bump.outputs.new_version }}
      bumped: ${{ steps.bump.outputs.bumped }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.PR_AUTOMATION_TOKEN || secrets.GITHUB_TOKEN }}

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Determine version bump
        id: bump
        run: |
          # Get commits since last version tag or last 20 commits
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          
          if [ -n "$LAST_TAG" ]; then
            COMMITS=$(git log $LAST_TAG..HEAD --pretty=format:"%s" 2>/dev/null || git log -20 --pretty=format:"%s")
          else
            COMMITS=$(git log -20 --pretty=format:"%s")
          fi
          
          echo "Recent commits:"
          echo "$COMMITS"
          
          # Determine bump type based on conventional commits
          BUMP_TYPE="patch"
          
          if echo "$COMMITS" | grep -qiE "^feat(\(.+\))?!:|BREAKING CHANGE"; then
            BUMP_TYPE="major"
          elif echo "$COMMITS" | grep -qiE "^feat(\(.+\))?:"; then
            BUMP_TYPE="minor"
          elif echo "$COMMITS" | grep -qiE "^fix(\(.+\))?:"; then
            BUMP_TYPE="patch"
          fi
          
          echo "Bump type: $BUMP_TYPE"
          
          # Get current version
          CURRENT_VERSION=$(node -p "require('./package.json').version")
          echo "Current version: $CURRENT_VERSION"
          
          # Calculate new version
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
          
          case $BUMP_TYPE in
            major)
              NEW_VERSION="$((MAJOR + 1)).0.0"
              ;;
            minor)
              NEW_VERSION="${MAJOR}.$((MINOR + 1)).0"
              ;;
            patch)
              NEW_VERSION="${MAJOR}.${MINOR}.$((PATCH + 1))"
              ;;
          esac
          
          echo "New version: $NEW_VERSION"
          
          # Check if version actually changed (avoid duplicate bumps)
          if [ "$CURRENT_VERSION" = "$NEW_VERSION" ]; then
            echo "Version already up to date"
            echo "bumped=false" >> $GITHUB_OUTPUT
            echo "new_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Update package.json
          node -e "
            const fs = require('fs');
            const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
            pkg.version = '$NEW_VERSION';
            fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2) + '\n');
          "
          
          echo "bumped=true" >> $GITHUB_OUTPUT
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "bump_type=$BUMP_TYPE" >> $GITHUB_OUTPUT

      - name: Commit version bump
        if: steps.bump.outputs.bumped == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add package.json
          git commit -m "chore: bump version to v${{ steps.bump.outputs.new_version }}"
          git push

      - name: Version bump summary
        run: |
          echo "### üì¶ Version Bump" >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.bump.outputs.bumped }}" = "true" ]; then
            echo "- **New Version:** v${{ steps.bump.outputs.new_version }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Bump Type:** ${{ steps.bump.outputs.bump_type }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "- **Status:** No version bump needed" >> $GITHUB_STEP_SUMMARY
            echo "- **Current Version:** v${{ steps.bump.outputs.new_version }}" >> $GITHUB_STEP_SUMMARY
          fi

  auto-pr-develop-to-main:
    name: Create PR from Develop to Main
    # Run when there's a push to develop branch (after version bump)
    if: github.event_name == 'push' && github.ref == 'refs/heads/develop'
    needs: [build, version-bump]
    runs-on: ubuntu-latest
    timeout-minutes: 5
    permissions:
      contents: read
      pull-requests: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: develop  # Get latest including version bump commit

      - name: Create PR develop to main
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PR_AUTOMATION_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const head = 'develop';
            const base = 'main';

            // Read version from package.json
            let version = '0.0.0';
            try {
              const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
              version = pkg.version || '0.0.0';
            } catch (err) {
              core.warning(`Could not read package.json version: ${err.message}`);
            }

            // Check if there's already an open PR from develop to main
            let existingPrs = [];
            try {
              const res = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                head: `${context.repo.owner}:${head}`,
                base,
                state: 'open',
                per_page: 1,
              });
              existingPrs = res.data;
            } catch (err) {
              if (err.status !== 404) throw err;
              core.warning('Could not list PRs (404). Proceeding to attempt creation.');
            }

            if (existingPrs.length > 0) {
              core.info(`PR from develop to main already exists: #${existingPrs[0].number} ${existingPrs[0].html_url}`);
              return;
            }

            // Check if develop is ahead of main
            let comparison;
            try {
              comparison = await github.rest.repos.compareCommits({
                owner: context.repo.owner,
                repo: context.repo.repo,
                base,
                head,
              });
            } catch (err) {
              core.warning(`Could not compare branches: ${err.message}`);
              return;
            }

            if (comparison.data.ahead_by === 0) {
              core.info('Develop branch is not ahead of main. No PR needed.');
              return;
            }

            console.log(`Develop is ${comparison.data.ahead_by} commits ahead of main.`);
            
            // Generate organized commit list
            const commits = comparison.data.commits || [];
            const grouped = { feat: [], fix: [], chore: [], docs: [], refactor: [], test: [], other: [] };
            
            commits.forEach(commit => {
              const msg = commit.commit.message.split('\n')[0];
              const shortSha = commit.sha.substring(0, 7);
              const line = `- ${msg} (\`${shortSha}\`)`;
              
              if (msg.startsWith('feat')) grouped.feat.push(line);
              else if (msg.startsWith('fix')) grouped.fix.push(line);
              else if (msg.startsWith('chore')) grouped.chore.push(line);
              else if (msg.startsWith('docs')) grouped.docs.push(line);
              else if (msg.startsWith('refactor')) grouped.refactor.push(line);
              else if (msg.startsWith('test')) grouped.test.push(line);
              else grouped.other.push(line);
            });
            
            let organizedCommits = '';
            if (grouped.feat.length) organizedCommits += '\n### ‚ú® Features\n' + grouped.feat.join('\n') + '\n';
            if (grouped.fix.length) organizedCommits += '\n### üêõ Bug Fixes\n' + grouped.fix.join('\n') + '\n';
            if (grouped.refactor.length) organizedCommits += '\n### ‚ôªÔ∏è Refactors\n' + grouped.refactor.join('\n') + '\n';
            if (grouped.docs.length) organizedCommits += '\n### üìù Documentation\n' + grouped.docs.join('\n') + '\n';
            if (grouped.test.length) organizedCommits += '\n### üß™ Tests\n' + grouped.test.join('\n') + '\n';
            if (grouped.chore.length) organizedCommits += '\n### üîß Chores\n' + grouped.chore.join('\n') + '\n';
            if (grouped.other.length) organizedCommits += '\n### üì¶ Other Changes\n' + grouped.other.join('\n') + '\n';

            const title = `release: v${version}`;
            const body = [
              '## üöÄ Release to Production',
              '',
              `**Version:** \`v${version}\``,
              `**Changes:** ${comparison.data.ahead_by} commits`,
              `**Branch:** \`${head}\` ‚Üí \`${base}\``,
              '',
              '## üìù Changes',
              organizedCommits || '*(No commits found)*',
              '',
              '## ‚úÖ Review Checklist',
              '',
              '- [ ] All tests are passing',
              '- [ ] Build is successful',
              '- [ ] No breaking changes',
              '- [ ] Ready for production deployment',
              '',
              '---',
              '*This PR was created automatically after changes were pushed to develop.*'
            ].join('\n');

            try {
              const res = await github.rest.pulls.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                head,
                base,
                title,
                body,
                maintainer_can_modify: true,
              });
              core.info(`Created PR #${res.data.number}: ${res.data.html_url}`);
            } catch (err) {
              if (err.status === 403) {
                core.setFailed('Permission denied to create PR. Check token permissions.');
              } else if (err.status === 404) {
                core.setFailed('Not Found creating PR. Check repository access.');
              } else if (err.status === 422) {
                core.info('PR could not be created - likely no differences between branches.');
              } else {
                throw err;
              }
            }
